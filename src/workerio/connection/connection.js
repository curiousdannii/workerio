import Platform from './../platform/platform';
/* global addEventListener */

/**
 * Connection encapsulates all worker or window port and provides standardized
 * interface for client and server to communicate with each other
 *
 * @module workerio
 * @namespace workerio.connection
 * @class Connection
 */
var Connection = Platform.Object.extend(
    Platform.Evented,
    {

        port: null,
        iface: null,
        timeout: 2000,
        serverDefinition: null,
        autoDefinitionRetrieval: true,

        init: function () {
            this.initPort();
            if (this.autoDefinitionRetrieval) {
                this.initDefinitionRetrieval();
            }
        },

        initPort: function () {
            // validate port
            if (!this.port || !this.port.postMessage) {
                throw new Error('Invalid port');
            }
            // validate iface name
            if (!this.iface) {
                throw new Error('Interface name not specified');
            }

            // interconnect with port
            this.port.addEventListener("message", function (event) {
                var data = event.data;

                // ignore non workerio messages
                // ignore messages from other connections
                if (data.prt === Connection.MSG_PROTOCOL && data.ifc === this.iface) {
                    this.trigger('message', data);

                    if (data.t === Connection.MSG_TYPE_REQUEST) {
                        this.trigger('request', data);
                        return;
                    }

                    if (data.t === Connection.MSG_TYPE_RESPONSE) {
                        this.trigger('response', data);
                        return;
                    }

                    if (data.t === Connection.MSG_TYPE_DEFINITION) {
                        this.trigger('definition', data);
                        return;
                    }

                    throw new Error('Unsupported message type');

                }

            }.bind(this));
        },

        initDefinitionRetrieval: function () {
            if (!this.serverDefinition) {
                this.serverDefinition = this

                    .waitForMessage(function (response) {
                        return (
                        response.t === Connection.MSG_TYPE_DEFINITION
                        );
                    }, true, `Interface definition of ${this.iface} has not been received in defined timeout.`)

                    .then(function (message) {
                        return message.def;
                    });
            }
            return this.serverDefinition;
        },

        retrieveDefinition: function () {
            this.initDefinitionRetrieval();
            return this.serverDefinition;

        },

        sendDefinition: function (serverDefinition) {
            const l = location
            const origin = typeof window != 'undefined' && this.port===window
                ? `${l.protocol}//${l.hostname}:${l.port}` : undefined;
            this.port.postMessage({
                prt: Connection.MSG_PROTOCOL,
                ifc: this.iface,
                t: Connection.MSG_TYPE_DEFINITION,
                def: serverDefinition
            }, origin);
        },


        waitForMessage: function (condition, useTimeout, timeoutMessage = null) {
            return new Platform.Promise(function (resolve, reject) {
                var listener, timeout;

                // listen for response
                listener = this.on('message', function (response) {
                    if (condition(response)) {
                        this.un(listener);
                        clearTimeout(timeout);
                        resolve(response);
                    }
                }.bind(this));

                if (useTimeout) {
                    // set response timeout
                    timeout = setTimeout(function () {
                        this.un(listener);
                        clearTimeout(timeout);

                        var message = 'Request timeouted.';
                        if (timeoutMessage) {
                            message = message + ' ' + timeoutMessage;
                        }
                        reject(new Error(message));
                    }.bind(this), this.timeout);
                }

            }.bind(this));
        },

        /**
         * Used by built server callees to respond for incomming request
         *
         * @param {request} request request object generated by request method
         * @param {Boolean} isSuccess whether call has been sucess or not
         * @param boolean args return arguments of the call
         * @returns {Object} Response structure
         */
        respond: function (request, isSuccess, args) {

            // create base response
            var response = {
                // protocol
                prt: Connection.MSG_PROTOCOL,
                // message type
                t: Connection.MSG_TYPE_RESPONSE,
                // was success
                s: isSuccess,
                // interface name
                ifc: this.iface,
                // dialog to pair with request
                d: request.d
            };

            if (isSuccess) {
                // assign params when success on callee
                response.a = args;
            } else {
                // assign params when error on callee
                var error = {
                    m: typeof args.message === 'string' ? args.message : String(args),
                    s: typeof args.stack === 'string' ? args.stack : ''
                };
                response.a = error;
            }

            const l = location
            const origin = typeof window != 'undefined' && this.port===window
                ? `${l.protocol}//${l.hostname}:${l.port}` : undefined;
            this.port.postMessage(response, origin);

            return response;
        },

        /**
         * Used by build client callees to request remote callee call
         *
         * @param {String} callee name
         * @param {Object }args arguments for callee
         * @returns {Promise}
         */
        request: function (callee, args) {
            let request, listener, timeout;

            //@todo: better random dialog
            // create request object
            request = {
                // protocol
                prt: Connection.MSG_PROTOCOL,
                // message type
                t: Connection.MSG_TYPE_REQUEST,
                // interface name
                ifc: this.iface,
                // dialog for pairing rx and tx
                d: Math.random(),
                // method name
                m: callee,
                // method arguments
                a: args
            };

            var promise = this.waitForMessage(function (response) {
                return (
                response.t === Connection.MSG_TYPE_RESPONSE &&
                response.d === request.d
                );
            });

            // post the message
            const l = location
            const origin = typeof window != 'undefined' && this.port===window
                ? `${l.protocol}//${l.hostname}:${l.port}` : undefined;
            this.port.postMessage(request, origin);

            // resolve errors
            promise = promise.then(function(response) {
                if (!response.s) {
                    var message = response.a.m ? response.a.m : 'Unexpected error';
                    var error = new Error(message);
                    error.stack = response.a.s;
                    throw error;
                }
                return response;
            });

            return promise;
        }


    });


Object.defineProperty(Connection, 'MSG_TYPE_REQUEST', {
    value: 'rx',
    writable: false
});

Object.defineProperty(Connection, 'MSG_TYPE_RESPONSE', {
    value: 'tx',
    writable: false
});

Object.defineProperty(Connection, 'MSG_TYPE_DEFINITION', {
    value: 'def',
    writable: false
});

Object.defineProperty(Connection, 'MSG_PROTOCOL', {
    value: 'wio',
    writable: false
});


export default Connection;
